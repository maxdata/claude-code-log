#!/usr/bin/env python3
"""Test cases for the utils module functions."""

import pytest
from claude_code_log.utils import (
    is_system_message,
    is_command_message,
    is_local_command_output,
    is_bash_input,
    is_bash_output,
    should_skip_message,
    should_use_as_session_starter,
    extract_text_content_length,
)
from claude_code_log.models import TextContent, ToolUseContent


class TestSystemMessageDetection:
    """Test system message detection functionality."""

    def test_is_system_message_caveat(self):
        """Test detection of caveat system messages."""
        caveat_text = "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."
        assert is_system_message(caveat_text) is True

    def test_is_system_message_interrupt(self):
        """Test detection of interrupt system messages."""
        interrupt_text = "[Request interrupted by user for tool use]"
        assert is_system_message(interrupt_text) is True

    def test_is_system_message_stdout(self):
        """Test detection of local command stdout system messages."""
        stdout_text = "<local-command-stdout> tags (always at the beginning)"
        assert is_system_message(stdout_text) is True

    def test_is_system_message_normal_text(self):
        """Test that normal text is not detected as system message."""
        normal_text = "This is a regular user message with normal content."
        assert is_system_message(normal_text) is False

    def test_is_system_message_partial_match(self):
        """Test that partial matches don't trigger system message detection."""
        partial_text = "Caveat: This is just a regular caveat, not a system message."
        assert is_system_message(partial_text) is False

    def test_is_system_message_empty_string(self):
        """Test system message detection with empty string."""
        assert is_system_message("") is False

    def test_is_system_message_whitespace_only(self):
        """Test system message detection with whitespace."""
        assert is_system_message("   \n\t  ") is False


class TestCommandMessageDetection:
    """Test command message detection functionality."""

    def test_is_command_message_complete(self):
        """Test detection of complete command messages."""
        command_text = "<command-name>ls</command-name><command-message>List files</command-message>"
        assert is_command_message(command_text) is True

    def test_is_command_message_with_args(self):
        """Test detection of command messages with arguments."""
        command_text = "<command-name>cd</command-name><command-args>/home/user</command-args><command-message>Change directory</command-message>"
        assert is_command_message(command_text) is True

    def test_is_command_message_only_name(self):
        """Test that only command-name tag is not sufficient."""
        command_text = "<command-name>ls</command-name>"
        assert is_command_message(command_text) is False

    def test_is_command_message_only_message(self):
        """Test that only command-message tag is not sufficient."""
        command_text = "<command-message>List files</command-message>"
        assert is_command_message(command_text) is False

    def test_is_command_message_normal_text(self):
        """Test that normal text is not detected as command message."""
        normal_text = "This is a regular message about commands."
        assert is_command_message(normal_text) is False

    def test_is_command_message_empty_string(self):
        """Test command message detection with empty string."""
        assert is_command_message("") is False


class TestLocalCommandOutput:
    """Test local command output detection functionality."""

    def test_is_local_command_output_present(self):
        """Test detection of local command output tags."""
        output_text = "Some text <local-command-stdout>output here</local-command-stdout> more text"
        assert is_local_command_output(output_text) is True

    def test_is_local_command_output_standalone(self):
        """Test detection of standalone stdout tags."""
        output_text = "<local-command-stdout>"
        assert is_local_command_output(output_text) is True

    def test_is_local_command_output_normal_text(self):
        """Test that normal text is not detected as command output."""
        normal_text = "This is regular text without command output tags."
        assert is_local_command_output(normal_text) is False

    def test_is_local_command_output_empty_string(self):
        """Test command output detection with empty string."""
        assert is_local_command_output("") is False


class TestBashCommandDetection:
    """Test bash command input/output detection functionality."""

    def test_is_bash_input_complete(self):
        """Test detection of complete bash input tags."""
        bash_text = "<bash-input>pwd</bash-input>"
        assert is_bash_input(bash_text) is True

    def test_is_bash_input_with_complex_command(self):
        """Test detection with complex bash commands."""
        bash_text = "<bash-input>ls -la /home/user | grep .txt</bash-input>"
        assert is_bash_input(bash_text) is True

    def test_is_bash_input_incomplete(self):
        """Test that incomplete bash input tags are not detected."""
        # Only opening tag
        assert is_bash_input("<bash-input>pwd") is False
        # Only closing tag
        assert is_bash_input("pwd</bash-input>") is False
        # Wrong tag name
        assert is_bash_input("<bash-command>pwd</bash-command>") is False

    def test_is_bash_input_empty_command(self):
        """Test detection of empty bash input."""
        bash_text = "<bash-input></bash-input>"
        assert is_bash_input(bash_text) is True

    def test_is_bash_input_normal_text(self):
        """Test that normal text is not detected as bash input."""
        normal_text = "This is a regular message without bash tags"
        assert is_bash_input(normal_text) is False


class TestBashOutputDetection:
    """Test bash output detection functionality."""

    def test_is_bash_output_stdout_only(self):
        """Test detection of bash stdout."""
        output_text = "<bash-stdout>/home/user</bash-stdout><bash-stderr></bash-stderr>"
        assert is_bash_output(output_text) is True

    def test_is_bash_output_stderr_only(self):
        """Test detection of bash stderr."""
        output_text = "<bash-stdout></bash-stdout><bash-stderr>Error: File not found</bash-stderr>"
        assert is_bash_output(output_text) is True

    def test_is_bash_output_both(self):
        """Test detection with both stdout and stderr."""
        output_text = (
            "<bash-stdout>Output</bash-stdout><bash-stderr>Warning</bash-stderr>"
        )
        assert is_bash_output(output_text) is True

    def test_is_bash_output_stdout_tag_only(self):
        """Test detection with just stdout tag present."""
        output_text = "Some text with <bash-stdout> tag"
        assert is_bash_output(output_text) is True

    def test_is_bash_output_stderr_tag_only(self):
        """Test detection with just stderr tag present."""
        output_text = "Some text with <bash-stderr> tag"
        assert is_bash_output(output_text) is True

    def test_is_bash_output_normal_text(self):
        """Test that normal text is not detected as bash output."""
        normal_text = "This is regular text without bash output tags"
        assert is_bash_output(normal_text) is False

    def test_is_bash_output_empty_tags(self):
        """Test detection of empty output tags."""
        output_text = "<bash-stdout></bash-stdout><bash-stderr></bash-stderr>"
        assert is_bash_output(output_text) is True


class TestMessageSkipping:
    """Test the centralized message skipping logic."""

    def test_should_skip_system_message_without_command(self):
        """Test that system messages without commands are skipped."""
        caveat_text = "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."
        assert should_skip_message(caveat_text) is True

    def test_should_not_skip_system_message_with_command(self):
        """Test that system messages with commands are not skipped."""
        command_text = "Caveat: some text <command-name>ls</command-name><command-message>List files</command-message>"
        assert should_skip_message(command_text) is False

    def test_should_not_skip_normal_message(self):
        """Test that normal messages are not skipped."""
        normal_text = "This is a regular user message."
        assert should_skip_message(normal_text) is False

    def test_should_not_skip_command_only_message(self):
        """Test that command-only messages are not skipped."""
        command_text = "<command-name>git</command-name><command-message>Git command</command-message>"
        assert should_skip_message(command_text) is False

    def test_should_skip_interrupt_message(self):
        """Test that interrupt messages are skipped."""
        interrupt_text = "[Request interrupted by user for tool use]"
        assert should_skip_message(interrupt_text) is True


class TestSessionStarterSelection:
    """Test the session starter message selection logic."""

    def test_should_use_normal_message_as_starter(self):
        """Test that normal messages can be used as session starters."""
        normal_text = "Hello, can you help me with this project?"
        assert should_use_as_session_starter(normal_text) is True

    def test_should_not_use_system_message_as_starter(self):
        """Test that system messages cannot be used as session starters."""
        caveat_text = "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."
        assert should_use_as_session_starter(caveat_text) is False

    def test_should_use_init_command_as_starter(self):
        """Test that init commands can be used as session starters."""
        init_text = "<command-name>init</command-name><command-message>Initialize project</command-message>"
        assert should_use_as_session_starter(init_text) is True

    def test_should_not_use_other_commands_as_starter(self):
        """Test that non-init commands cannot be used as session starters."""
        command_text = "<command-name>ls</command-name><command-message>List files</command-message>"
        assert should_use_as_session_starter(command_text) is False

    def test_should_not_use_git_command_as_starter(self):
        """Test that git commands cannot be used as session starters."""
        git_text = "<command-name>git</command-name><command-message>Git status</command-message>"
        assert should_use_as_session_starter(git_text) is False

    def test_should_use_message_with_command_name_in_content(self):
        """Test that messages mentioning commands in content can be used as starters."""
        content_text = "I want to run the init command to set up my project."
        assert should_use_as_session_starter(content_text) is True

    def test_should_not_use_empty_string_as_starter(self):
        """Test that empty strings cannot be used as session starters."""
        assert (
            should_use_as_session_starter("") is True
        )  # Empty strings are not system/command messages


class TestTextContentLength:
    """Test the text content length extraction functionality."""

    def test_extract_text_content_length_string(self):
        """Test length extraction from string content."""
        content = "Hello world, this is a test message."
        assert extract_text_content_length(content) == len(content)

    def test_extract_text_content_length_string_with_whitespace(self):
        """Test length extraction from string with leading/trailing whitespace."""
        content = "   Hello world   "
        assert extract_text_content_length(content) == len("Hello world")

    def test_extract_text_content_length_empty_string(self):
        """Test length extraction from empty string."""
        content = ""
        assert extract_text_content_length(content) == 0

    def test_extract_text_content_length_whitespace_only(self):
        """Test length extraction from whitespace-only string."""
        content = "   \n\t   "
        assert extract_text_content_length(content) == 0

    def test_extract_text_content_length_list_with_text(self):
        """Test length extraction from list with text content."""
        text_item = TextContent(type="text", text="Hello world")
        content = [text_item]
        assert extract_text_content_length(content) == len("Hello world")

    def test_extract_text_content_length_list_with_multiple_text(self):
        """Test length extraction from list with multiple text items."""
        text_item1 = TextContent(type="text", text="Hello ")
        text_item2 = TextContent(type="text", text="world!")
        content = [text_item1, text_item2]
        # Each item is stripped, so "Hello " becomes "Hello" (5 chars) + "world!" (6 chars) = 11 chars
        assert extract_text_content_length(content) == 11

    def test_extract_text_content_length_list_with_mixed_content(self):
        """Test length extraction from list with mixed content types."""
        text_item = TextContent(type="text", text="Hello world")
        tool_item = ToolUseContent(
            type="tool_use", id="tool1", name="TestTool", input={"key": "value"}
        )
        content = [text_item, tool_item]
        # Only text content should be counted
        assert extract_text_content_length(content) == len("Hello world")

    def test_extract_text_content_length_list_no_text(self):
        """Test length extraction from list with no text content."""
        tool_item = ToolUseContent(
            type="tool_use", id="tool1", name="TestTool", input={"key": "value"}
        )
        content = [tool_item]
        assert extract_text_content_length(content) == 0

    def test_extract_text_content_length_empty_list(self):
        """Test length extraction from empty list."""
        content = []
        assert extract_text_content_length(content) == 0


class TestEdgeCases:
    """Test edge cases and error conditions."""

    def test_functions_with_none_input(self):
        """Test that functions handle None input gracefully."""
        # Most functions should handle None by treating it as empty/false
        with pytest.raises(AttributeError):
            is_system_message(None)  # type: ignore
        with pytest.raises(TypeError):
            is_command_message(None)  # type: ignore
        with pytest.raises(TypeError):
            is_local_command_output(None)  # type: ignore

    def test_functions_with_non_string_input(self):
        """Test that functions handle non-string input with TypeError."""
        # All of these should raise TypeError when using `in` with non-string types
        with pytest.raises(TypeError):
            is_command_message(123)  # type: ignore
        with pytest.raises(TypeError):
            is_local_command_output(123)  # type: ignore
        with pytest.raises(AttributeError):
            is_system_message(123)  # type: ignore

    def test_should_skip_message_edge_cases(self):
        """Test edge cases for message skipping logic."""
        # Test with very long system message
        long_caveat = (
            "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."
            + "x" * 1000
        )
        assert should_skip_message(long_caveat) is True

        # Test with system message that also has command
        mixed_message = "Caveat: The messages below were generated by the user while running local commands. <command-name>init</command-name><command-message>Init</command-message>"
        assert should_skip_message(mixed_message) is False

    def test_session_starter_edge_cases(self):
        """Test edge cases for session starter selection."""
        # Test with very long init command
        long_init = (
            "<command-name>init</command-name><command-message>"
            + "x" * 1000
            + "</command-message>"
        )
        assert should_use_as_session_starter(long_init) is True

        # Test with init in the middle of command name
        init_middle = "<command-name>reinit</command-name><command-message>Reinitialize</command-message>"
        assert should_use_as_session_starter(init_middle) is False
